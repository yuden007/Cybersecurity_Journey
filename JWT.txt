__________________________________________________________________________________________


JWT authentication bypass via unverified signature:

WEAKNESS:
The server doesn't verify the signature of any JWTs that it receives. 

OBSERVATION:
After post-login GET /my-account request, observe that your session cookie is a JWT.
Decode the JWT to JSON form, notice that the JWT sub field contains your username.
Change /my-account to /admin then send, notice that it's only accessible when logged in as the administrator.

SOLUTION:
Change value of the JWT sub field from username to administrator.
Update your new JWT and send the GET /admin request again, admin panel is accessible now.

__________________________________________________________________________________________


JWT authentication bypass via flawed signature verification:

WEAKNESS:
The server accepts unsigned JWTs. 

OBSERVATION:
After post-login GET /my-account request, observe that your session cookie is a JWT.
Decode the JWT to JSON form, notice that the JWT sub field contains your username.
Change /my-account to /admin then send, notice that it's only accessible when logged in as the administrator.

SOLUTION:
Change value of the JWT sub field from username to administrator.
Change the value of the JWT alg field to "none".
Leave the signature blank, don't remove the last dot..
Update your new JWT and send the GET /admin request again, admin panel is accessible now.

__________________________________________________________________________________________


JWT authentication bypass via weak signing key:

WEAKNESS:
The server uses an extremely weak secret key to sign and verify tokens, can be easily brute-forced with wordlist.

OBSERVATION:
After post-login GET /my-account request, observe that your session cookie is a JWT.
Decode the JWT to JSON form, notice that the JWT sub field contains your username.
Change /my-account to /admin then send, notice that it's only accessible when logged in as the administrator.
Can't just change the JWT sub field because if so the signature isn't gonna match, we need to resign the entrie JWT, but we need the secret key to do so and we do not know what it is.

SOLUTION:
Copy the JWT and brute-force the secret. You can do this using hashcat as follows:
hashcat -a 0 -m 16500 <YOUR-JWT> /path/to/wordlist 
Using Burp Decoder, Base64 encode the secret that you brute-forced in the previous section. 
In Burp, go to the JWT Editor Keys tab and click New Symmetric Key, generate a new key in JWK format. 
Replace the generated value for the k property with the Base64-encoded secret, then save the key.
Change value of the JWT sub field from username to administrator.
Sign the header and payload, gives us a new valid signature.
Update your new JWT and send the GET /admin request again, admin panel is accessible now.

__________________________________________________________________________________________


JWT authentication bypass via jwk header injection:

WEAKNESS:
The server blindly trusts a public key embedded in the JWT header via the jwk parameter.

OBSERVATION:
After post-login GET /my-account request, observe that your session cookie is a JWT.
Decode the JWT to JSON form, notice that the JWT sub field contains your username.
Change /my-account to /admin then send, notice that it's only accessible when logged in as the administrator.

SOLUTION:
Change value of the JWT sub field from username to administrator.
Generate s new RSA key. In JSON Web Token extension, click Attack, with your new key embedded.
Observe that a jwk parameter has been added containing your public key. 
Update your new JWT and send the GET /admin request again, admin panel is accessible now.

__________________________________________________________________________________________


JWT authentication bypass via jku header injection:

WEAKNESS:
The server supports the jku parameter in the JWT header. 
But fails to check whether the provided URL belongs to a trusted domain before fetching the key. 

OBSERVATION:
After post-login GET /my-account request, observe that your session cookie is a JWT.
Decode the JWT to JSON form, notice that the JWT sub field contains your username.
Change /my-account to /admin then send, notice that it's only accessible when logged in as the administrator.

SOLUTION:
Generate a new RSA key, copy public key as JWK.
Paste the JWK in body on the exploit server as { "keys": [ YOUR_JWK ] }, change Content-Type to application/json.
Back to Burp, replace your old kid field's value with your new one.
Add a new jku field in the header with the URL of your exploit server as value. 
Change value of the JWT sub field from username to administrator.
Sign your JWT with your RSA key, beware not to modify header. 
Update your new JWT and send the GET /admin request again, admin panel is accessible now.

__________________________________________________________________________________________


JWT authentication bypass via kid header path traversal:

WEAKNESS:

OBSERVATION:
After post-login GET /my-account request, observe that your session cookie is a JWT.
Decode the JWT to JSON form, notice that the JWT sub field contains your username.
Change /my-account to /admin then send, notice that it's only accessible when logged in as the administrator.

SOLUTION:
Generate new symmetric key in JWK format.
Replace the empty k property value with Base64-encoded null byte (AA==), else JWT extension won't allow signing.
In Burp Repeater, change the kid parameter's value to ../../../../../../../dev/null 
Change value of the JWT sub field from username to administrator.
Sign your JWT with your symmetric key, beware not to modify header. 
Update your new JWT and send the GET /admin request again, admin panel is accessible now.

__________________________________________________________________________________________


Appendix:

JWT: Base64URL-encode(JSON object)
format: encodedHeader.encodedPayload.encodedSignature
{
  "header": {
    "alg": "HS256",
    "typ": "JWT",
    "kid": "key-id-123",
    "cty": "application/json"
  },
  "payload": {
    "iss": "https://auth.example.com",         // Issuer
    "sub": "user-789",                         // Subject (user ID)
    "aud": "https://api.example.com",          // Audience
    "exp": 1736812800,                         // Expiration time (Unix timestamp)
    "nbf": 1736809200,                         // Not before time
    "iat": 1736809200,                         // Issued at time
    "jti": "jwt-id-456",                       // JWT ID (unique token ID)
    "role": "admin",                           // Custom claim
    "email": "user@example.com",               // Custom claim
    "permissions": ["read", "write", "delete"] // Custom claim
  },
  "signature": "dBjftJeZ4CVP-mB92K27uhbUJU1p1r_wW1gFWFOEjXk"
}


JWT Processor:
Can use JWT extension in Burp Suite or hashcat
hashcat -a 0 -m 16500 <YOUR-JWT> /path/to/jwt.secrets.list 
Avoid using online JWT processor to prevent violation.

/dev/null:
A special device file that acts as a black hole for data. 
Anything written to it is discarded immediately, and reading from it always returns end-of-file (EOF).
